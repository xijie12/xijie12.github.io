<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>don&#39;t be evil</title>
  
  <subtitle>sakura ovq</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuraus.cn/"/>
  <updated>2018-11-02T08:44:55.127Z</updated>
  <id>https://www.sakuraus.cn/</id>
  
  <author>
    <name>sakura ovo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker-machine</title>
    <link href="https://www.sakuraus.cn/2018/11/02/docker-machine/"/>
    <id>https://www.sakuraus.cn/2018/11/02/docker-machine/</id>
    <published>2018-11-02T08:44:55.127Z</published>
    <updated>2018-11-02T08:44:55.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-machine-Docker-Machine-介绍"><a href="#docker-machine-Docker-Machine-介绍" class="headerlink" title="docker-machine Docker Machine 介绍"></a>docker-machine Docker Machine 介绍</h1><h2 id="为什么需要Docker-Machine"><a href="#为什么需要Docker-Machine" class="headerlink" title="为什么需要Docker Machine"></a>为什么需要Docker Machine</h2><blockquote><ul><li>Docker Machine 介绍</li></ul></blockquote><blockquote><ul><li>Docker Machine 是 Docker 官方编排项目之一，负责在多种平台上快速安装 Docker 环境。   </li><li>Docker Machine 是一个工具，它允许你在虚拟宿主机上安装 Docker Engine ，并使用 docker-machine 命令管理这些宿主机。你可以使用 Machine 在你本地的 Mac 或 Windows box、公司网络、数据中心、或像 阿里云 或 华为云这样的云提供商上创建 Docker 宿主机。</li></ul></blockquote><blockquote><ul><li>使用 docker-machine 命令，你可以启动、审查、停止和重新启动托管的宿主机、升级 Docker 客户端和守护程序、并配置 Docker 客户端与你的宿主机通信</li><li>为什么要使用它？</li></ul></blockquote><pre><code>在没有Docker Machine之前，你可能会遇到以下问题：1、你需要登录主机，按照主机及操作系统特有的安装以及配置步骤安装Docker，使其能运行Docker容器。2、你需要研发一套工具管理多个Docker主机并监控其状态。Docker Machine的出现解决了以上问题。1、Docker Machine简化了部署的复杂度，无论是在本机的虚拟机上还是在公有云平台，只需要一条命令便可搭建好Docker主机2、Docker Machine提供了多平台多Docker主机的集中管理部署3、Docker Machine 使应用由本地迁移到云端变得简单，只需要修改一下环境变量即可和任意Docker主机通信部署应用。</code></pre><blockquote><ul><li>Docker的组成：</li></ul></blockquote><pre><code>1、Docker daemon2、一套与 Docker daemon 交互的 REST API3、一个命令行客户端</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker-machine-relation.png" alt="Alt text" title="docker-machine">                </div>                <div class="image-caption">docker-machine</div>            </figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \&gt; install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><ul><li>用Docker Machine可以批量安装和配置docker host，其支持在不同的环境下安装配置docker host，包括：</li></ul></blockquote><blockquote><ul><li>常规 Linux 操作系统</li></ul></blockquote><blockquote><ul><li>虚拟化平台 - VirtualBox、VMWare、Hyper-V</li></ul></blockquote><blockquote><ul><li>公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、阿里、华为等</li></ul></blockquote><blockquote><ul><li>普通方式，仅供参考</li></ul></blockquote><blockquote><ul><li>创建一个名为cluster-master1 的主机，驱动方式是virtualbox<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox  cluster-master1</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>报错提示没有发现VBoxManage。因此，需要手工安装</li></ul></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker-machine-err.png" alt="Alt text" title="docker-machine">                </div>                <div class="image-caption">docker-machine</div>            </figure><blockquote><ul><li>编辑yum 源<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/virtualbox.repo</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>写入以下信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[virtualbox]</span><br><span class="line">name=Oracle Linux / RHEL / CentOS-<span class="variable">$releasever</span> / <span class="variable">$basearch</span> - VirtualBox</span><br><span class="line">baseurl=http://download.virtualbox.org/virtualbox/rpm/el/<span class="variable">$releasever</span>/<span class="variable">$basearch</span></span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://www.virtualbox.org/download/oracle_vbox.asc</span><br><span class="line"></span><br><span class="line">yum search VirtualBox  <span class="comment">#查找具体安装版本</span></span><br><span class="line"></span><br><span class="line">yum  install  VirtualBox</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>还有可能出现报错内核不一致</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker-machine-cpu.png" alt="Alt text" title="docker-machine "></p><blockquote><ul><li>根据提示下载指定的版本<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum  install  kernel-devel-3.10.0-862.2.3.el7.x86_64 </span><br><span class="line">yum  install  VirtualBox</span><br><span class="line">vboxconfig  <span class="comment">#重新加载执行下，再次创建</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>继续报错，没有开启虚拟化，云服务器默认是不能开启的，云服务器有云服务器的驱动，目前阿里云、华为云有这种驱动，同时比如阿里云的驱动是可以在腾讯云使用，也可以在本地<br>使用，这个不造成影响。</li></ul></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker-machine-esc_err.png" alt="Alt text" title="docker-machine">                </div>                <div class="image-caption">docker-machine</div>            </figure><blockquote><ul><li>第三方驱动支持列表<br>   <a href="https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md" target="_blank" rel="noopener">https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md</a></li></ul></blockquote><h2 id="第三方驱动使用"><a href="#第三方驱动使用" class="headerlink" title="第三方驱动使用"></a>第三方驱动使用</h2><blockquote><ul><li>1、下载驱动 二进制文件也可用，可以从以下链接下载：</li></ul></blockquote><pre><code>Mac OSX 64位：https://docker-machine-drivers.oss-cn-beijing.aliyuncs.com/docker-machine-driver-aliyunecs_darwin-amd64.tgzLinux  64位 :https://docker-machine-drivers.oss-cn-beijing.aliyuncs.com/docker-machine-driver-aliyunecs_linux-amd64.tgzWindows 64位：https://docker-machine-drivers.oss-cn-beijing.aliyuncs.com/docker-machine-driver-aliyunecs_windows-amd64.tgz</code></pre><blockquote><ul><li>2、解压安装<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://docker-machine-drivers.oss-cn-beijing.aliyuncs.com/docker-machine-driver-aliyunecs_linux-amd64.tgz </span><br><span class="line"> tar xzvf driver-aliyunecs.tgz -C docker-machine</span><br><span class="line">mv ./bin/docker-machine-driver-aliyunecs.linux-amd64 /usr/<span class="built_in">local</span>/bin/docker-machine-driver-aliyunecs     </span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine-driver-aliyunecs</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>想要创建一个阿里云虚拟化实例，需要满足几个条件</li></ul></blockquote><pre><code>1、账户余额大于100，因为创建的实例为按量付费2、设置accesskey，要具备操作账户的权限</code></pre><h3 id="阿里云驱动安装"><a href="#阿里云驱动安装" class="headerlink" title="阿里云驱动安装"></a>阿里云驱动安装</h3><blockquote><ul><li>登录阿里云账号控制台<a href="https://home.console.aliyun.com/new#/，选择accesskey" target="_blank" rel="noopener">https://home.console.aliyun.com/new#/，选择accesskey</a></li></ul></blockquote><p>   <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker-machine-ali_login.png" alt="Alt text" title="docker-machine-ali_login "><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d aliyunecs </span><br><span class="line">--aliyunecs-io-optimized=optimized    </span><br><span class="line">--aliyunecs-description=aliyunecs-machine-driver  </span><br><span class="line">--aliyunecs-instance-type=ecs.mn4.small   </span><br><span class="line">--aliyunecs-access-key-id=LTAIJIGa4sFefl1g </span><br><span class="line"> --aliyunecs-access-key-secret=AlA7CV6zjntg7Q1zO3sGvIMIAxJi3m</span><br><span class="line"> --aliyunecs-region=cn-hangzhou  </span><br><span class="line">--aliyunecs-ssh-password=zaq1@wsxmanager</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>–aliyunecs-io-optimized=optimized     //磁盘io优化</li><li>–aliyunecs-description=aliyunecs-machine-driver   //描述</li><li>–aliyunecs-instance-type=ecs.mn4.small     //实例规格</li><li>–aliyunecs-access-key-id=LTxxxcxx      // key</li><li>–aliyunecs-access-key-secret=Axxx     //秘钥</li><li>–aliyunecs-region=cn-hangzhou     //地区</li><li>--aliyunecs-ssh-password=zaq1@wsx  //ssh登录密码</li><li>–aliyunecs-image-id=centos_7_04_64_20G_alibase_201701015.vhd  //镜像实例</li><li>docker-machine 管理</li></ul></blockquote><pre><code>两台服务器本地主机：47.98.147.4xx远程主机：xxx.xxx.xxx</code></pre><blockquote><ul><li>Scp操作<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine scp  worker:/root/foo.txt  .</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>mount 操作<br>云服务器，不能使用（可能）</li></ul></blockquote><blockquote><ul><li>手册 <a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">https://docs.docker.com/machine/install-machine/</a></li></ul></blockquote><h2 id="创建dockr虚拟宿主机"><a href="#创建dockr虚拟宿主机" class="headerlink" title="创建dockr虚拟宿主机"></a>创建dockr虚拟宿主机</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker-machine-Docker-Machine-介绍&quot;&gt;&lt;a href=&quot;#docker-machine-Docker-Machine-介绍&quot; class=&quot;headerlink&quot; title=&quot;docker-machine Docker Machin
      
    
    </summary>
    
      <category term="docker" scheme="https://www.sakuraus.cn/categories/docker/"/>
    
      <category term="docker-machine" scheme="https://www.sakuraus.cn/categories/docker/docker-machine/"/>
    
    
      <category term="docker" scheme="https://www.sakuraus.cn/tags/docker/"/>
    
      <category term="docker-machine" scheme="https://www.sakuraus.cn/tags/docker-machine/"/>
    
  </entry>
  
  <entry>
    <title>docker-swarm</title>
    <link href="https://www.sakuraus.cn/2018/11/02/docker-swarm/"/>
    <id>https://www.sakuraus.cn/2018/11/02/docker-swarm/</id>
    <published>2018-11-02T08:41:55.921Z</published>
    <updated>2018-11-02T08:41:55.921Z</updated>
    
    <content type="html"><![CDATA[<p>#Docker swarm </p><p>##介绍，为什么需要Docker swarm </p><p>##Docker swarm 跟docker的关系</p><p>##创建dockr swarm集群实现伸缩调度</p><h3 id="一、Docker-swarm-介绍"><a href="#一、Docker-swarm-介绍" class="headerlink" title="一、Docker swarm 介绍"></a>一、Docker swarm 介绍</h3><blockquote><ul><li>　   Swarm是Docker公司推出的用来管理docker集群，它将一群Docker宿主机变成一个单一的，虚拟的主机。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client(docker client in Go, docker_py, docker等)均可以直接与Swarm通信。</li><li>Swarm几乎全部用go语言来完成开发，Swarm0.2发布，相比0.1版本，0.2版本增加了一个新的策略来调度集群中的容器，使得在可用的节点上传播它们，以及支持更多的Docker命令以及集群驱动。</li></ul></blockquote><blockquote><ul><li>Swarm deamon只是一个调度器（Scheduler）加路由器(router)，Swarm自己不运行容器，它只是接受docker客户端发送过来的请求，调度适合的节点来运行容器，这意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，当Swarm重新恢复运行之后，它会收集重建集群信息．</li></ul></blockquote><p>  结构图：<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker_swarm.png" alt="Alt text" title="docker_swarm.png">                </div>                <div class="image-caption">docker_swarm.png</div>            </figure></p><h4 id="一、为什么要使用它？"><a href="#一、为什么要使用它？" class="headerlink" title="一、为什么要使用它？"></a>一、为什么要使用它？</h4><blockquote><ul><li>1、应用想要扩容到两台以上的服务器上，多台服务器总是比单台服务器复杂，可以使用docker-swarm进行集群化的管理跟伸缩</li></ul></blockquote><blockquote><ul><li>2、应用是否有高可用的要求，在docker swarm集群中有两种不同类型的节点，Master节点和Worker节点,其中的一个Master节点是Leader,如果当前Leader宕机不可用，其他健康的Master中的一台会自动成为Leader 。如果Worker节点宕机不可用，宕机节点上的容器实例会被重新调度到其他健康的Worker节点上。</li></ul></blockquote><p>####一、关键概念</p><blockquote><ul><li>Swarm</li></ul></blockquote><pre><code>集群的管理和编排是使用嵌入到docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</code></pre><blockquote><ul><li>Node</li></ul></blockquote><pre><code>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 ( node )</code></pre><blockquote><ul><li>节点分为管理 ( manager ) 节点和工作 ( worker ) 节点。</li></ul></blockquote><blockquote><ul><li>管理节点用于 Swarm 集群的管理， docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。</li></ul></blockquote><blockquote><ul><li>一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader ， leader 通过 raft 协议实现</li></ul></blockquote><blockquote><ul><li>工作节点是任务执行节点，管理节点将服务 ( service ) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</li></ul></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker_swarm_node.png" alt="Alt text" title="docker_swarm_node">                </div>                <div class="image-caption">docker_swarm_node</div>            </figure><blockquote><ul><li>服务和任务</li></ul></blockquote><pre><code>任务 （ Task ）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。服务 （ Services ） 是指一组任务的集合，服务定义了任务的属性。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker_swarm_relation.png" alt="Alt text" title="docker_swarm_relation">                </div>                <div class="image-caption">docker_swarm_relation</div>            </figure><p>###docker swarm init 命令参考<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/fanyinjiang/markdownImage/master/docker_swarm_init.png" alt="Alt text" title="docker_swarm_init">                </div>                <div class="image-caption">docker_swarm_init</div>            </figure></p><blockquote><ul><li>–cert-expiry<br>设置节点证书有效期</li><li>–dispatcher-heartbeat<br>设置节点报告它们的健康状态间隔的时间。</li><li>–external-ca value<br>设置集群使用一个外部CA来签发节点证书。value的格式为protocol=X,url=Y。protocol指定的是发送签名请求到外部CA所使用的协议。目前只支持cfssl。URL指定的是签名请求应该提交到哪个endpoint。</li><li>–force-new-cluster<br>强制一个失去仲裁能力的集群的其中一个节点重启成为一单节点集群，而不丢失数据。</li><li>–listen-addr value<br>在这个地址监听集群管理相关流量。默认是监听0.0.0.0:2377。也可以指定一个网络接口来监听这个接口的地址。例如–listen-addr eth0:2377。<br>端口是可选的。如果仅指定IP地址或接口名称，端口就使用默认的2377。</li><li>–advertise-addr value<br>指定通告给集群的节点的地址，这个地址用来给其它节点访问API和overlay网络通信。如果没有指定地址，docker将检查系统是否只有一个IP地址，如果是将使用这个地址并使用监听的端口(查看–listen-addr)。如果系统有多个IP地址，–advertise-addr就必须指定一个以便内部管理节点能够正常通信和overlay网络通信。<br>也可以指定一个网络接口来通告接口的地址，例如–advertise-addr eth0:2377。<br>端口是可选的。如果仅指定一个IP地址或接口名称，就使用端口2377。</li><li>–task-history-limit<br>设置任务历史记录保留限制。<br>1、初始化<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr xx.xx.xx</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>2、加入集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> docker swarm join-token worker #可以查看加入节点的token</span><br><span class="line">docker swarm join --token SWMTKN-1-1oxfayeqathm39flfmtuglt3l3xpdkemellw8iyom0h99h5ebu-e4tfrqla6uqgzjgo1r4t84rtt 47.98.109.204:2377</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>3、查看节点<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>4、部署服务<br>在manager节点部署nginx服务，服务数量为10个，公开指定端口是8080映射容器80,使用nginx镜像<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 3 -p 80:80 --name nginx  nginx</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Docker swarm &lt;/p&gt;
&lt;p&gt;##介绍，为什么需要Docker swarm &lt;/p&gt;
&lt;p&gt;##Docker swarm 跟docker的关系&lt;/p&gt;
&lt;p&gt;##创建dockr swarm集群实现伸缩调度&lt;/p&gt;
&lt;h3 id=&quot;一、Docker-swarm-
      
    
    </summary>
    
      <category term="docker" scheme="https://www.sakuraus.cn/categories/docker/"/>
    
      <category term="docker-swarm" scheme="https://www.sakuraus.cn/categories/docker/docker-swarm/"/>
    
    
      <category term="docker" scheme="https://www.sakuraus.cn/tags/docker/"/>
    
      <category term="docker-swarm" scheme="https://www.sakuraus.cn/tags/docker-swarm/"/>
    
  </entry>
  
  <entry>
    <title>gitlab部署必须条件</title>
    <link href="https://www.sakuraus.cn/2018/10/31/gitlab%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.sakuraus.cn/2018/10/31/gitlab部署/</id>
    <published>2018-10-31T13:13:32.356Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitlab部署必须条件"><a href="#gitlab部署必须条件" class="headerlink" title="gitlab部署必须条件"></a>gitlab部署必须条件</h2><ol><li>代码必须外部挂载，单独保存，不因为容器或者机器的释放而丢失</li><li>必须自定义域名</li><li>能使用邮箱发送功能</li><li>最好是中文的</li></ol><h2 id="详细部署步骤"><a href="#详细部署步骤" class="headerlink" title="详细部署步骤"></a>详细部署步骤</h2><h3 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h3><ol><li>创建文件存储服务NAS，利用文件存储服务来满足代码不因容器和机器的释放而丢失</li><li>文件存储服务-创建 NFS 文件系统</li><li>创建一个挂载点</li><li>容器服务-数据卷-创建一个数据卷，名称为gitlab，其他参数使用上面创建的挂载点参数<br>这样我们就创建了一个单独数据卷来保存我们文件，只要部署时把这个数据卷映射到数据文件上就OK了。</li></ol><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><ol><li>申请163邮箱账号用于邮件发送<br>申请成功后，注意开通POP3,SMTP功能，拿到授权码</li></ol><h2 id="SLB"><a href="#SLB" class="headerlink" title="SLB"></a>SLB</h2><p> 创建集群，设置SLB 名称为 gitlab_com</p><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p> 创建自定义编排文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gitlab:</span><br><span class="line">  image: &apos;twang2218/gitlab-ce-zh:latest&apos;</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;80&apos;</span><br><span class="line">    - &apos;10012:22&apos;</span><br><span class="line">    - &apos;443&apos;</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    - &apos;GITLAB_OMNIBUS_CONFIG=external_url &apos;&apos;http://gitlab.lingdianit.com&apos;&apos;;gitlab_rails[&apos;&apos;smtp_enable&apos;&apos;] = true;gitlab_rails[&apos;&apos;smtp_address&apos;&apos;] = &quot;smtp.163.com&quot;;gitlab_rails[&apos;&apos;smtp_port&apos;&apos;] = 25;gitlab_rails[&apos;&apos;smtp_user_name&apos;&apos;] = &quot;gitlablingdian@163.com&quot;;gitlab_rails[&apos;&apos;smtp_password&apos;&apos;] = &quot;tuandui1234&quot;;gitlab_rails[&apos;&apos;smtp_domain&apos;&apos;] = &quot;163.com&quot;;gitlab_rails[&apos;&apos;smtp_authentication&apos;&apos;] = &quot;login&quot;;gitlab_rails[&apos;&apos;smtp_enable_starttls_auto&apos;&apos;] = true;gitlab_rails[&apos;&apos;gitlab_email_from&apos;&apos;] = &quot;gitlablingdian@163.com&quot;;user[&quot;git_user_email&quot;] = &quot;gitlablingdian@163.com&quot;;&apos;</span><br><span class="line">  labels:</span><br><span class="line">    aliyun.probe.url: &apos;tcp://container:80&apos;</span><br><span class="line">    aliyun.probe.initial_delay_seconds: &apos;10&apos;</span><br><span class="line">    aliyun.scale: &apos;1&apos;</span><br><span class="line">    aliyun.routing.port_80: &apos;http://gitlab.lingdianit.com&apos;</span><br><span class="line">    aliyun.lb.port_22: &apos;tcp://gitlab_com:22&apos;</span><br><span class="line">  volumes:</span><br><span class="line">    - &apos;gitlab:/var/opt/gitlab:rw&apos;</span><br></pre></td></tr></table></figure></p><p>  编排文件中注意点<br>  enviroment  GITLAB_OMNIBUS_CONFIG</p><p>  建议使用图形页面添加,前面填写  GITLAB_OMNIBUS_CONFIG ,后面格式为<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_url &apos;http://gitlab.lingdianit.com&apos;;gitlab_rails[&apos;smtp_enable&apos;] = true;gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.163.com&quot;;gitlab_rails[&apos;smtp_port&apos;] = 25;gitlab_rails[&apos;smtp_user_name&apos;] = &quot;gitlablingdian@163.com&quot;;gitlab_rails[&apos;smtp_password&apos;] = &quot;tuandui1234&quot;;gitlab_rails[&apos;smtp_domain&apos;] = &quot;163.com&quot;;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true;gitlab_rails[&apos;gitlab_email_from&apos;] = &quot;gitlablingdian@163.com&quot;;user[&quot;git_user_email&quot;] = &quot;gitlablingdian@163.com&quot;;</span><br></pre></td></tr></table></figure></p><p>  类似上面这个格式，如果你需要更改其他参数，请参考<a href="http://docs.gitlab.com/omnibus/docker/" target="_blank" rel="noopener">gitlab官方</a></p><p>  容器路由的问题</p><p>   实现http很简单，只需这么一句<br>  <figure class="highlight plain"><figcaption><span>'http://gitlab.lingdianit.com' ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">表示容器的80端口，映射到这个域名,多域名可用 ; 分割</span><br><span class="line"></span><br><span class="line">暴露22端口问题，我们需要用到  自定义负载均衡的 lb 标签</span><br><span class="line"></span><br><span class="line">下面举个例子，简单讲述下这个自定义 lb的理解</span><br></pre></td></tr></table></figure></p><pre><code>aliyun.lb.port_22: &apos;tcp://gitlab_com:22&apos;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    第一个端口22,是容器的端口 ,第二个端口22 指的是 gitlab_com 的 slb 前端端,</span><br><span class="line">    负载均衡的后端端口 应该是主机的端口，这时到文件中去查找 22 对应主机端口是 10012,</span><br><span class="line">    所以负载均衡22 的后端端口应该是10012,自己在负载均衡上添加一条22:10012 记录</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">### 使用编排文件部署应用</span><br><span class="line"></span><br><span class="line">### 集群管理，使用本地管理集群</span><br><span class="line">- 下载证书</span><br><span class="line">  集权-管理-下载证书</span><br><span class="line">- 本地配置</span><br><span class="line">  建立使用别名，添加到 .bashrc</span><br></pre></td></tr></table></figure><p>alias docker-private=’docker –tlsverify –tlscacert=/Users/xufei/aliyun/private/ca.pem –tlscert=/Users/xufei/aliyun/private/cert.pem –tlskey=/Users/xufei/aliyun/private/key.pem -H=tcp://master4g5.cs-cn-hangzhou.aliyun.com:21004’</p><p>source .bashrc </p><p>docker-private ps  //就能查看集群所有容器了<br><code>`</code></p><h3 id="其他注意概念"><a href="#其他注意概念" class="headerlink" title="其他注意概念"></a>其他注意概念</h3><ul><li>应用<br>一个应该可包含多个服务</li><li>服务<br>应用的组成部分</li><li>节点<br>集群的机器节点，有时需要彻底清理机器，可以使用重置节点，会清空整个磁盘</li><li>数据集<br>我们主动创建的数据卷 或者 容器内部 主动暴露 的 volume ,有时我们需要重新部署，建议主动删除数据集，不然以前的数据，配置信息总还在</li></ul><h3 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h3><ul><li><a href="https://github.com/twang2218/gitlab-ce-zh" target="_blank" rel="noopener">gitlab中文镜像-https://github.com/twang2218/gitlab-ce-zh</a></li><li><a href="http://docs.gitlab.com/omnibus/docker/" target="_blank" rel="noopener">gitlabce-官方docker指南</a></li><li><a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/files/gitlab-config-template/gitlab.rb.template" target="_blank" rel="noopener">gitlabce-所有配置项简介</a></li><li><a href="https://help.aliyun.com/document_detail/48484.html?spm=5176.doc25974.6.594.xpzVJ4" target="_blank" rel="noopener">阿里云-自定义lb标签简介</a></li><li><a href="http://www.cnblogs.com/wenwei-blog/p/6286944.html" target="_blank" rel="noopener">gitlab-163邮箱配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gitlab部署必须条件&quot;&gt;&lt;a href=&quot;#gitlab部署必须条件&quot; class=&quot;headerlink&quot; title=&quot;gitlab部署必须条件&quot;&gt;&lt;/a&gt;gitlab部署必须条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;代码必须外部挂载，单独保存，不因为容器或者机器的
      
    
    </summary>
    
      <category term="gitlab" scheme="https://www.sakuraus.cn/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="https://www.sakuraus.cn/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之 facade 模式</title>
    <link href="https://www.sakuraus.cn/2018/10/31/facade/"/>
    <id>https://www.sakuraus.cn/2018/10/31/facade/</id>
    <published>2018-10-31T13:13:31.915Z</published>
    <updated>2018-08-19T06:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="laravel-框架实现的门面模式"><a href="#laravel-框架实现的门面模式" class="headerlink" title="laravel 框架实现的门面模式"></a>laravel 框架实现的门面模式</h2><blockquote><ul><li>什么是门面模式,在我的理解范围中主要为对象提供高级接口</li><li>为什么要使用门面模式, 在传统开发中最难过就是文件迁移 </li><li>现在都是基于命名空间开发的框架,一旦文件迁移的了 <code>use</code>这个类的文件都需要修改提升了维护成本,也限制了可扩展性</li><li>在使用门面模式之后我们为一个公共类型实现一个高级接口外部调用,只需要引入门面既可以调用</li><li>实现第一步需要为类提供给门面在<code>laravel</code>框架中首先需要定义自己的facade 然后可以在<code>app.php</code>的配置文件中<code>alias</code>别名中映射门面相当于给门面给了一个别名</li><li>通过 <code>static</code> 获取<strong>上下文环境</strong>获取外观模式中的 别名 然后通过 反转获取到 Ioc 容器中的实例 <code>__callStatic()</code>实现调用</li></ul></blockquote><h3 id="静态延迟绑定"><a href="#静态延迟绑定" class="headerlink" title="静态延迟绑定"></a>静态延迟绑定</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;laravel-框架实现的门面模式&quot;&gt;&lt;a href=&quot;#laravel-框架实现的门面模式&quot; class=&quot;headerlink&quot; title=&quot;laravel 框架实现的门面模式&quot;&gt;&lt;/a&gt;laravel 框架实现的门面模式&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="laravel" scheme="https://www.sakuraus.cn/categories/laravel/"/>
    
    
      <category term="设计模式" scheme="https://www.sakuraus.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="php" scheme="https://www.sakuraus.cn/tags/php/"/>
    
      <category term="laravel" scheme="https://www.sakuraus.cn/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建一个微服务架构</title>
    <link href="https://www.sakuraus.cn/2018/10/31/docker-compose/"/>
    <id>https://www.sakuraus.cn/2018/10/31/docker-compose/</id>
    <published>2018-10-31T13:13:31.679Z</published>
    <updated>2018-09-02T04:28:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><blockquote><ul><li>服务 ( service )：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 ( project )：由一组关联的应用容器组成的一个完整业务单元。</li></ul></blockquote><pre><code>可见，一个项目可以由多个服务（容器）关联而成， Compose 面向项目进行管理。</code></pre><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><blockquote><ul><li>dockerfile是构建镜像的一个语法文件 类似<code>shell</code> 脚本 的语法 详情参考<a href="https://docs.docker-cn.com/" target="_blank" rel="noopener">docker</a></li></ul></blockquote><h2 id="docker-compose-1"><a href="#docker-compose-1" class="headerlink" title="docker-compose"></a>docker-compose</h2><blockquote><ul><li>是可以构建多个服务的编排文件 现在有几个版本的编排语法 基本都是兼容的主要高版本加了一些新语法</li><li>使用高版本的时候注意<code>docker</code>版本 </li><li>下面我列举出构建一个示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot; #不同版本支持的语法不同具</span><br><span class="line">services: #服务 编排的好处在于不用手动的去一次运行镜像 实现自动化docker很轻松就能部署一个项目</span><br><span class="line">    swoft1: # 服务名称</span><br><span class="line">        container_name: swoft-server1 # 运行的容器名称</span><br><span class="line">        image: swofts # 指定为镜像名称或镜像 ID。如果镜像在本地不存在， Compose 将会尝试拉取这个镜像。</span><br><span class="line">        ports: # 暴露端口信息 前面对应宿主机的端口 : 后面对应容器里面开放的端口</span><br><span class="line">            - &quot;8003:9502&quot;</span><br><span class="line">            - &quot;8004:9504&quot;</span><br><span class="line">            - &quot;8005:8099&quot;</span><br><span class="line">        links: # 容器依靠的其他服务 这种方式是通过查询同一个网络中的服务</span><br><span class="line">            - db</span><br><span class="line">            - redis</span><br><span class="line">            - consul-client</span><br><span class="line">        volumes: # 共享卷 前面对应宿主机的地址:后面把宿主机的地址映射到容器里面的地址</span><br><span class="line">             - /www/swoft:/var/www/swoft</span><br><span class="line">        stdin_open: true #</span><br><span class="line">        network_mode: &quot;mynetwork&quot; #设置网络模式。使用和 docker run 的 --network 参数一样的值。</span><br><span class="line">        tty: true # 模拟一个伪终端</span><br><span class="line">        command: [/bin/bash] # 覆盖容器启动后默认执行的命令。</span><br><span class="line"></span><br><span class="line">    swoft2:</span><br><span class="line">            container_name: swoft-server2</span><br><span class="line">            image: swofts</span><br><span class="line">            ports:</span><br><span class="line">                - &quot;8006:9502&quot;</span><br><span class="line">                - &quot;8007:9504&quot;</span><br><span class="line">                - &quot;8008:8099&quot;</span><br><span class="line">            links:</span><br><span class="line">                - db</span><br><span class="line">                - redis</span><br><span class="line">                - consul-client</span><br><span class="line">            volumes:</span><br><span class="line">                 - /www/swoft:/var/www/swoft</span><br><span class="line">            stdin_open: true</span><br><span class="line">            network_mode: &quot;mynetwork&quot;</span><br><span class="line">            tty: true</span><br><span class="line">            command: [/bin/bash]</span><br><span class="line">    redis:</span><br><span class="line">          container_name: redis</span><br><span class="line">          image: redis</span><br><span class="line">          ports:</span><br><span class="line">            - &quot;6378:6379&quot;</span><br><span class="line">          volumes:</span><br><span class="line">            - /etc/redis.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">          network_mode: &quot;mynetwork&quot;</span><br><span class="line">    db:</span><br><span class="line">          container_name: mysql</span><br><span class="line">          image: mysql:5.7</span><br><span class="line">          environment:</span><br><span class="line">             MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">          ports:</span><br><span class="line">            - &quot;3307:3306&quot;</span><br><span class="line">          network_mode: &quot;mynetwork&quot;</span><br><span class="line"></span><br><span class="line">    consul-server:</span><br><span class="line">              container_name: consul-server</span><br><span class="line">              image: consul</span><br><span class="line">              ports:</span><br><span class="line">                     - &quot;32240:8300&quot;</span><br><span class="line">                     - &quot;32241:8301&quot;</span><br><span class="line">                     - &quot;32242:8301/udp&quot;</span><br><span class="line">                     - &quot;32243:8302/udp&quot;</span><br><span class="line">                     - &quot;32244:8302&quot;</span><br><span class="line">                     - &quot;32245:8500&quot;</span><br><span class="line">                     - &quot;32246:8600&quot;</span><br><span class="line">                     - &quot;32247:8600/udp&quot;</span><br><span class="line">              stdin_open: true</span><br><span class="line">              network_mode: &quot;mynetwork&quot;</span><br><span class="line">              tty: true</span><br><span class="line">              command: /bin/bash</span><br><span class="line"></span><br><span class="line">    consul-server1:</span><br><span class="line">              container_name: consul-server1</span><br><span class="line">              image: consul</span><br><span class="line">              ports:</span><br><span class="line">                - &quot;32252:8300&quot;</span><br><span class="line">                - &quot;32253:8301&quot;</span><br><span class="line">                - &quot;32254:8301/udp&quot;</span><br><span class="line">                - &quot;32255:8302/udp&quot;</span><br><span class="line">                - &quot;32256:8302&quot;</span><br><span class="line">                - &quot;32257:8500&quot;</span><br><span class="line">                - &quot;32258:8600&quot;</span><br><span class="line">                - &quot;32259:8600/udp&quot;</span><br><span class="line">              links:</span><br><span class="line">                - consul-server</span><br><span class="line">              stdin_open: true</span><br><span class="line">              network_mode: &quot;mynetwork&quot;</span><br><span class="line">              tty: true</span><br><span class="line">              command: /bin/bash</span><br><span class="line"></span><br><span class="line">    consul-server2:</span><br><span class="line">              container_name: consul-server2</span><br><span class="line">              image: consul</span><br><span class="line">              ports:</span><br><span class="line">                   - &quot;32260:8300&quot;</span><br><span class="line">                   - &quot;32261:8301&quot;</span><br><span class="line">                   - &quot;32262:8301/udp&quot;</span><br><span class="line">                   - &quot;32263:8302/udp&quot;</span><br><span class="line">                   - &quot;32264:8302&quot;</span><br><span class="line">                   - &quot;32265:8500&quot;</span><br><span class="line">                   - &quot;32266:8600&quot;</span><br><span class="line">                   - &quot;32267:8600/udp&quot;</span><br><span class="line">              links:</span><br><span class="line">                   - consul-server</span><br><span class="line">              stdin_open: true</span><br><span class="line">              network_mode: &quot;mynetwork&quot;</span><br><span class="line">              tty: true</span><br><span class="line">              command: /bin/bash</span><br><span class="line">    consul-client:</span><br><span class="line">                  container_name: consul-client</span><br><span class="line">                  image: consul</span><br><span class="line">                  ports:</span><br><span class="line">                       - &quot;32270:8300&quot;</span><br><span class="line">                       - &quot;32271:8301&quot;</span><br><span class="line">                       - &quot;32272:8301/udp&quot;</span><br><span class="line">                       - &quot;32273:8302/udp&quot;</span><br><span class="line">                       - &quot;32274:8302&quot;</span><br><span class="line">                       - &quot;32275:8500&quot;</span><br><span class="line">                       - &quot;32276:8600&quot;</span><br><span class="line">                       - &quot;32277:8600/udp&quot;</span><br><span class="line">                  links:</span><br><span class="line">                     - consul-server</span><br><span class="line">                     - consul-server1</span><br><span class="line">                     - consul-server2</span><br><span class="line">                  stdin_open: true</span><br><span class="line">                  network_mode: &quot;mynetwork&quot;</span><br><span class="line">                  tty: true</span><br><span class="line">                  command: /bin/bash</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="PHP环境搭建、win7系统"><a href="#PHP环境搭建、win7系统" class="headerlink" title="PHP环境搭建、win7系统"></a>PHP环境搭建、win7系统</h3><blockquote><ul><li>一、docker软件的下载<br>1、下载地址:<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a><br>2、安装docker文件，直接点击下一步操作，完成后会自动安装VM和Git这两个文件。<br> ①安装过程中，会出现找不到，boot2docker这个文件，这个文件是docker的依赖，需要下载拷贝到docker的指定文件目录，(在报错位置)。<br> ②安装过程中出现enter press contiune … 情况，需要重启系统，按F2进入配置IO环境。更改配置。<br>3、安装完成后，docker会自动分配一个IP地址，默认的帐号和密码，使用Xshell进行连接操作。(帐号:docker，密码:tcuser)<br>4、以上连接完成后，进行镜像拉取，使用命令:docker pull 镜像名称，把镜像进行本地映射。<br>5、运行镜像，使用命令:docker run -i -t 镜像名称  /bin/bash<br> 如果出错，按出错提示进行操作。<br>6、docker run  -d -v /data:/data -p 80:80 -p 1229:1229  registry.aliyuncs.com/lingdianit/dev:v3  /etc/rc.local  //运行映射文件及端口，这里的配置，必须要和虚拟机中的映射文件一致,data/<br>7、常用命令的使用。<br>  docker -version         //查看版本<br>  docker  pull/push/search 镜像名称   //下载/上传/搜索镜像文件<br>  docker images           //列出所有安装过的镜像。<br>  docker start/stop/run/resart/kill 进程id   //docker启动/停止/运行/重启/杀掉  如:docker start a62<br>  docker ps  //查看映射文件</li></ul></blockquote><blockquote><ul><li>二、Xshell软件的下载<br>  Xshell主要使用的是连接docker。方便命令操作。</li></ul></blockquote><blockquote><ul><li>三、VM虚拟机的环境映射<br>1、本地磁盘中建立一个文件夹，后面需要映射的文件目录。<br>2、启动docker时就已经启动VM虚拟机，在启动过程中有如下设置：<br> 设置-&gt;共享文件价-&gt;添加共享文件-&gt;文件路径和文件目录(路径是本地文件的目录，文件目录是需要映射到虚拟机中的目录)。设置完成后需要重启虚拟机后生效。<br>3、重启Xshell，查看文件夹中映射的文件是否存在，存在则配置成功。未配置成功查看错误日志。</li></ul></blockquote><blockquote><ul><li>四、域名的绑定设置<br>  域名配置。C:\Windows\System32\drivers\etc\hosts.txt,如下配置:<br>  192.168.99.100  <a href="http://www.keloop.cn" target="_blank" rel="noopener">www.keloop.cn</a><br>  192.168.99.100  staitc.keloop.cn<br>  说明：前面是docker分配的IP地址，后面是配置访问的域名。</li></ul></blockquote><blockquote><ul><li>五、Git版本控制代码命令<br>  1、使用SSH模式进行操作<br>  2、全局配置：<br>  git config –global user.name “用户名”<br>  git config –global user.email 邮箱地址<br>  3、常见命令<br>  git init .                                  //初始化<br>  git add newfile                             //提交新文件到暂存区<br>  git commit -m ‘add new file’                //提交到本地仓库<br>  git remote add origin <a href="mailto:git@xx.com" target="_blank" rel="noopener">git@xx.com</a>:demo.git   //添加远程仓库地址<br>  git fetch origin  -p                        // 同步本地远程仓库镜像<br>  git push origin dev:dev                     //把本地dev 推送到远端<br>  git br  dev                                 //创建本地dev分支<br>  git br feature-new origin/dev               // 基于远端dev 创建新分支 feature-new<br>  git checkout -b feature-coupon origin/dev   //创建分支<br>  switched to a new branch “feature-coupon”   //切换分支<br>  git merge origin/dev                        //合并远端dev分支</li></ul></blockquote><pre><code>密钥生成及配置(仓库和本地密钥必须一致)ssh-keygen -t rsa  //生成密钥，产生id_rsa和id_rsa.pub本地密钥放在:C:\Users\Administrator\.ssh\  gitlab设置密钥：设置-&gt;SSH密钥-&gt;添加密钥</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker-compose&quot;&gt;&lt;a href=&quot;#docker-compose&quot; class=&quot;headerlink&quot; title=&quot;docker-compose&quot;&gt;&lt;/a&gt;docker-compose&lt;/h1&gt;&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot;
      
    
    </summary>
    
      <category term="docker" scheme="https://www.sakuraus.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.sakuraus.cn/tags/docker/"/>
    
      <category term="docker-compose" scheme="https://www.sakuraus.cn/tags/docker-compose/"/>
    
      <category term="MicroService" scheme="https://www.sakuraus.cn/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>镜像发布</title>
    <link href="https://www.sakuraus.cn/2018/10/31/%E5%BA%94%E7%94%A8%E5%8F%91%E7%89%88%E8%A7%84%E8%8C%83/"/>
    <id>https://www.sakuraus.cn/2018/10/31/应用发版规范/</id>
    <published>2018-10-31T13:13:31.449Z</published>
    <updated>2018-08-19T06:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试-上版制度"><a href="#测试-上版制度" class="headerlink" title="测试,上版制度"></a>测试,上版制度</h2><h3 id="web端的测试"><a href="#web端的测试" class="headerlink" title="web端的测试"></a>web端的测试</h3><ol><li>主要在二刀环境进行测试</li><li>三刀除了进行功能测试,还需要进行回归测试</li><li>大的改动一定要提前进行测试,如果存在数据恢复的问题,需要提前进行演练</li></ol><h3 id="客户端的测试"><a href="#客户端的测试" class="headerlink" title="客户端的测试"></a>客户端的测试</h3><ol><li>客户端包括电脑端+移动端，上版本之前的测试阶段分为三步，依次是：技术部内测、公司全部门内测、分时间段公测。其中技术部内测，需将测试包发给产品助理以及上传测试平台testin进行测试。</li><li>安卓和IOS工程师需获取全部APP下载人群所使用的手机版本，根据数据来决定最低兼容的手机系统版本号</li></ol><h3 id="上版时间规定"><a href="#上版时间规定" class="headerlink" title="上版时间规定"></a>上版时间规定</h3><p>所有系统的更新上版时间不能在周末节假日前一天，不能在订单高峰期时间。严格控制在早上10点以前，下午4点以前，超过规定时间则不予更新，十分紧急情况除外。</p><h3 id="上版代码管理情况"><a href="#上版代码管理情况" class="headerlink" title="上版代码管理情况"></a>上版代码管理情况</h3><ol><li>一般分为dev,release,master分支</li><li>上版使用release分支，一定要实际在三刀测试release分支，最后推送到master分支前，需要对release分支打上tag</li><li>上版以后要观察日志</li></ol><h3 id="关于二刀测试环境与三刀预上线环境说明"><a href="#关于二刀测试环境与三刀预上线环境说明" class="headerlink" title="关于二刀测试环境与三刀预上线环境说明"></a>关于二刀测试环境与三刀预上线环境说明</h3><h3 id="二刀环境"><a href="#二刀环境" class="headerlink" title="二刀环境"></a>二刀环境</h3><p>完全搭建一套独立环境,使用独立数据库,独立队列,完全模拟整个平台的运行</p><p>数据库 xx_test<br>队列  xx_test </p><h3 id="三刀预上线环境"><a href="#三刀预上线环境" class="headerlink" title="三刀预上线环境"></a>三刀预上线环境</h3><p>使用生产环境数据库 </p><p>使用独立队列</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试-上版制度&quot;&gt;&lt;a href=&quot;#测试-上版制度&quot; class=&quot;headerlink&quot; title=&quot;测试,上版制度&quot;&gt;&lt;/a&gt;测试,上版制度&lt;/h2&gt;&lt;h3 id=&quot;web端的测试&quot;&gt;&lt;a href=&quot;#web端的测试&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="上线" scheme="https://www.sakuraus.cn/categories/%E4%B8%8A%E7%BA%BF/"/>
    
    
      <category term="images" scheme="https://www.sakuraus.cn/tags/images/"/>
    
  </entry>
  
  <entry>
    <title>Api约束</title>
    <link href="https://www.sakuraus.cn/2018/10/31/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FAPI%E7%BA%A6%E5%AE%9A/"/>
    <id>https://www.sakuraus.cn/2018/10/31/应用程序API约定/</id>
    <published>2018-10-31T13:13:31.221Z</published>
    <updated>2018-08-19T06:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用约定"><a href="#通用约定" class="headerlink" title="通用约定"></a>通用约定</h2><ul><li>所有编码都采用UTF-8</li><li>日期格式采用yyyy-MM-dd方式，如2015-08-10</li><li>Content-type为application/json; charset=UTF-8</li></ul><h2 id="公共请求头"><a href="#公共请求头" class="headerlink" title="公共请求头"></a>公共请求头</h2><table><thead><tr><th>头域（Header）</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>Authorization</td><td>必须</td><td>包含Access Key与请求签名</td></tr><tr><td>Host</td><td>必须</td><td>包含API的域名</td></tr><tr><td>Content-Type</td><td>可选</td><td>application/json; charset=utf-8</td></tr></tbody></table><h2 id="公共响应头"><a href="#公共响应头" class="headerlink" title="公共响应头"></a>公共响应头</h2><table><thead><tr><th>头域(Header)</th><th>说明</th></tr></thead><tbody><tr><td>Content-Type</td><td>只支持JSON格式，application/json; charset=utf-8</td></tr></tbody></table><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>可使用 HTTP Status Codes <a href="https://tools.ietf.org/html/rfc7231#section-6" target="_blank" rel="noopener">RFC7231</a>，同时使用消息自定义的code来做业务处理</p><h2 id="通用错误返回格式"><a href="#通用错误返回格式" class="headerlink" title="通用错误返回格式"></a>通用错误返回格式</h2><p>当调用接口出错时，将返回通用的错误格式返回的消息体将包括全局唯一的请求、错误代码以及错误信息。调用方可根据错误码以及错误信息,requestid以便于快速地帮助您解决问题定位问题。</p><h2 id="消息体定义"><a href="#消息体定义" class="headerlink" title="消息体定义"></a>消息体定义</h2><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>request_id</td><td>String</td><td>请求的唯一标识</td></tr><tr><td>code</td><td>String</td><td>错误类型代码</td></tr><tr><td>message</td><td>String</td><td>错误的信息说明</td></tr></tbody></table><h2 id="公共错误码"><a href="#公共错误码" class="headerlink" title="公共错误码"></a>公共错误码</h2><p>每个项目组定义自己的业务code<br>建议以1000开始，定义code的主要意义是看==客户端是否需要根据code来区分这个错误==</p><h2 id="签名认证"><a href="#签名认证" class="headerlink" title="签名认证"></a>签名认证</h2><h3 id="第三方接口认证-AccessKeyId-AccessKeySecret-模型"><a href="#第三方接口认证-AccessKeyId-AccessKeySecret-模型" class="headerlink" title="第三方接口认证 AccessKeyId/AccessKeySecret 模型"></a>第三方接口认证 AccessKeyId/AccessKeySecret 模型</h3><p>AccessKeyId用于标示用户<br>AccessKeySecret是用户用于加密签名字符串</p><p>签名规则</p><p>所有请求字符串排序 + timestamp + uniq_nonce</p><p>timestatmp +-15分钟有效  uniq_nonce +-15 分钟只能使用一次</p><p>能防止重放和篡改，但是客户端密钥保存是个问题，特别是web端</p><p>临时token，可以解决sk泄露问题</p><h3 id="JWT模型"><a href="#JWT模型" class="headerlink" title="JWT模型"></a>JWT模型</h3><p>注意点：</p><ol><li>不能防止重放和篡改攻击</li><li>后台需要减少令牌的授权时间，实现客户端无感自动更新令牌</li><li>后台需要实现废弃令牌机制，比如用户更改密码，应该废弃以前所发的令牌</li></ol><h3 id="令牌提交方式"><a href="#令牌提交方式" class="headerlink" title="令牌提交方式"></a>令牌提交方式</h3><ol><li>Head  Authorization:token</li><li>url   url&amp;authorization=token</li></ol><h2 id="接口跨域问题"><a href="#接口跨域问题" class="headerlink" title="接口跨域问题"></a>接口跨域问题</h2><p>CORS 授权解决跨域问题<br>子域名可以通过设置 document.domain=parent.com 来取消跨域</p><h2 id="接口权限问题"><a href="#接口权限问题" class="headerlink" title="接口权限问题"></a>接口权限问题</h2><p>统一使用RBAC</p><h2 id="接口日志和限流问题"><a href="#接口日志和限流问题" class="headerlink" title="接口日志和限流问题"></a>接口日志和限流问题</h2><p>在接入层做拦截，实现限流和日志记录</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>通过url来区分</p><p>/v1/order/xxx</p><p>/v2/order/xxx</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>要求清晰，明了<br>/v1/order/crete<br>/v1/order/updateStatus</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>使用HTTPS</p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>只使用GET,POST, GET 用于查询，其他都用POST</p><h3 id="接口通用参数"><a href="#接口通用参数" class="headerlink" title="接口通用参数"></a>接口通用参数</h3><p>字段过滤  field=id,firstname<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: &quot;543abc&quot;,</span><br><span class="line">    &quot;first_name:&quot;: &quot;John&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: &quot;543add&quot;,</span><br><span class="line">    &quot;first_name:&quot;: &quot;Bob&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>条件过滤   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">是否关联资源 embed=orderitem  表示包含订单明细</span><br></pre></td></tr></table></figure></p><p>[<br>  {<br>      “order_id”:’111’,<br>      “orderitem”: {<br>           ‘food_name’:’test’<br>      }<br>  }<br>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">排序  ```sort=username,-updated_at``` - 降序</span><br><span class="line"></span><br><span class="line">分页  ``` page=0&amp;size=15 ```    //第一页 15条</span><br><span class="line"></span><br><span class="line">分页返回 data</span><br></pre></td></tr></table></figure></p><p>{<br>   ‘count’ =&gt; ‘11’,<br>   ‘cur_page’=&gt; 1,<br>   ‘data’ =&gt; {…}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经常使用的、复杂的查询标签化，降低维护成本。</span><br><span class="line"></span><br><span class="line">``` GET /trades?status=closed&amp;sort=created,desc</span><br></pre></td></tr></table></figure></p><p>缩写 <code>GET /trades#recently-closed</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通用约定&quot;&gt;&lt;a href=&quot;#通用约定&quot; class=&quot;headerlink&quot; title=&quot;通用约定&quot;&gt;&lt;/a&gt;通用约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有编码都采用UTF-8&lt;/li&gt;
&lt;li&gt;日期格式采用yyyy-MM-dd方式，如2015-08-10&lt;/li
      
    
    </summary>
    
      <category term="Api" scheme="https://www.sakuraus.cn/categories/Api/"/>
    
    
      <category term="api" scheme="https://www.sakuraus.cn/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Mysql规范</title>
    <link href="https://www.sakuraus.cn/2018/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
    <id>https://www.sakuraus.cn/2018/10/31/数据库规范/</id>
    <published>2018-10-31T13:13:30.249Z</published>
    <updated>2018-08-19T06:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库规范"><a href="#数据库规范" class="headerlink" title="数据库规范"></a>数据库规范</h1><h2 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h2><p>必须使用InnoDB存储引擎  </p><blockquote><ul><li>支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li></ul></blockquote><p>必须使用UTF8字符集,新库默认使用utf8mb4字符集  </p><blockquote><ul><li>万国码，无需转码，无乱码风险，节省空间</li></ul></blockquote><p>数据表、数据字段必须加入中文注释</p><p>禁止使用存储过程、视图、触发器、Event  </p><blockquote><ul><li>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧</li></ul></blockquote><p>禁止存储大文件或者大照片  </p><blockquote><ul><li>大文件和照片存储在文件系统，数据库里存URI多好</li></ul></blockquote><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>只允许使用内网域名，而不是ip连接数据库<br>线上环境、开发环境、测试环境数据库内网域名遵循命名规范</p><blockquote><ul><li>业务名称：yprinter  </li><li>本地环境：yprinter_local  </li><li>测试环境：yprinter_test  </li><li>线上环境：yprinter_pro  </li><li>从库在名称后加-s标识，备库在名称后加-ss标识  </li><li>线上从库：yprinter_pro-s  </li><li>线上备库：yprinter_pro-ss  </li></ul></blockquote><p>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用<br>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p><h2 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h2><p>单实例表数目必须小于500<br>单表列数目必须小于30<br>表必须有主键，例如自增主键</p><blockquote><ul><li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用  </li><li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率  </li><li>无主键的表删除，在row模式的主从架构，会导致备库夯住  </li></ul></blockquote><p>禁止 使用外键，如果有外键完整性约束，需要应用程序控制：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能，甚至造成死锁。大数据高并发业务场景下数据使用以性能优先</p><h2 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h2><p>必须把字段定义为NOT NULL并且提供默认值</p><blockquote><ul><li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li><li>null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识</li><li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</li></ul></blockquote><p>合理使用TEXT、BLOB类型  </p><blockquote><ul><li>TEXT,BLOB类型数据请使用垂直分表,把这类数据分离开来,</li></ul></blockquote><p>禁止使用小数存储货币  </p><blockquote><ul><li>使用整数吧，小数容易导致钱对不上</li></ul></blockquote><p>必须使用varchar(20)存储手机号</p><blockquote><ul><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么?</li><li>varchar可以支持模糊查询，例如：like“138%”</li></ul></blockquote><p>访问频率较低的大字段拆分出数据表</p><blockquote><ul><li>详情</li></ul></blockquote><p>并不需要一定遵守范式理论，适度的冗余，让Query尽量减少Join</p><p>禁止使用ENUM，可使用TINYINT代替</p><blockquote><ul><li>增加新的ENUM值要做DDL操作</li><li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串</li></ul></blockquote><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><p>单表索引建议控制在5个以内<br>单索引字段数不允许超过5个<br>禁止在更新十分频繁、区分度不高的属性上建立索引</p><blockquote><ul><li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</li></ul></blockquote><p>建立组合索引，必须把区分度高的字段放在前面  </p><blockquote><ul><li>在order by或者group by子句中，如果想通过索引来进行排序，所建索引列的顺序必须与order by或者group by子句的顺序一致，并且所有列的排序方向（倒序或者正序）都一样</li><li>联合索引中的字段应尽量满足过滤数据从多到少的顺序，也就是说差异最大的字段应该房子第一个字段</li></ul></blockquote><h2 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h2><p>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p><blockquote><ul><li>读取不需要的列会增加CPU、IO、NET消耗</li><li>不能有效的利用覆盖索引</li><li>使用SELECT *容易在增加或者删除字段后出现程序BUG</li></ul></blockquote><p>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性  </p><blockquote><ul><li>容易在增加或者删除字段后出现程序BUG</li></ul></blockquote><p>禁止使用属性隐式转换</p><blockquote><ul><li>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，</li><li>phone是varchar类型，SQL语句带入的是整形，故不会命中索引，加个引号就好了：</li><li>SELECT uid FROM t_user WHERE phone=’13812345678’ </li></ul></blockquote><p>禁止在WHERE条件的属性上使用函数或者表达式</p><blockquote><ul><li>SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描</li><li>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li></ul></blockquote><p>禁止负向查询，以及%开头的模糊查询</p><blockquote><ul><li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描</li></ul></blockquote><p>禁止大表使用JOIN查询，禁止大表使用子查询<br>禁止使用OR条件，必须改为IN查询<br>应用程序必须捕获SQL异常，并有相应处理  </p><blockquote><ul><li>select * from student where name=’you’ or name=’me’ or name=’he’</li><li>可以改成 select * from student where name in (‘you’,’me’,’he’);</li></ul></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>禁止使用应用程序配置文件内的帐号手工访问线上数据库<br>开发、测试、线上环境隔离<br>数据库状态字段选择尽量不要使用0，php本身对0判断不友好</p><h2 id="时间字段的选择-timestamp-datetime-int"><a href="#时间字段的选择-timestamp-datetime-int" class="headerlink" title="时间字段的选择 timestamp,datetime,int"></a>时间字段的选择 timestamp,datetime,int</h2><ol><li>最主要的区别-受时区影响不同。timestamp会跟随设置的时区变化而变化，而datetime保存的是绝对值不会变化。</li><li>占用存储空间不同。timestamp储存占用4个字节，datetime储存占用8个字节</li><li>可表示的时间范围不同。timestamp可表示范围:1970-01-01 00:00:00~2038-01-09 03:14:07，datetime支持的范围更宽1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>索引速度不同。timestamp更轻量，索引相对datetime更快。</li><li>使用时间戳的唯一考虑是：你的应用是否涉及多时区，时间数据是否和时区相关。如果回答“是”，那么就必须使用时间戳，没有任何第二方案。如果不涉及,建议使用timestamp<br>显示更直观</li></ol><h2 id="每个表增加create-time、update-time两个字段"><a href="#每个表增加create-time、update-time两个字段" class="headerlink" title="每个表增加create_time、update_time两个字段"></a>每个表增加create_time、update_time两个字段</h2><ol><li>分别表示写入时间以及最后更新时间</li><li>业务上可能用不到,但是对日常运维管理则非常有用</li><li>可以用来判断哪些是可以归档的老数据,定期进行归档 </li><li>用来做自定义的差异备份也很方便</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959906&amp;idx=1&amp;sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&amp;chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc#rd" target="_blank" rel="noopener">58到家数据库30条军规解读</a></p><p><a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1494055166&amp;ver=1&amp;signature=xqjBIqXRrTSrhO9bVfPMKw*Gg90a6ZTGaG2SA1uH4jOUTN1KOorK30nmorj9iQUGe0OH*XvA3P5zm4IRHEgQ-oiLKp0cX76iDLgi61XwI4WkP3MDtROPNqTX762WihEK2UqjI5QmINfW*Kr36wneipSUTpnUrCG8CuSLBXdq5zA=" target="_blank" rel="noopener">再议数据库军规</a></p><p><a href="https://segmentfault.com/q/1010000000655428" target="_blank" rel="noopener">时间戳的选择</a></p><p><a href="mysql_opt.pdf">阿里数据库优化</a></p><p><a href="https://cloud.tencent.com/developer/article/1004367" target="_blank" rel="noopener">mysql优化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库规范&quot;&gt;&lt;a href=&quot;#数据库规范&quot; class=&quot;headerlink&quot; title=&quot;数据库规范&quot;&gt;&lt;/a&gt;数据库规范&lt;/h1&gt;&lt;h2 id=&quot;基础规范&quot;&gt;&lt;a href=&quot;#基础规范&quot; class=&quot;headerlink&quot; title=&quot;基础规范&quot;
      
    
    </summary>
    
      <category term="Mysql" scheme="https://www.sakuraus.cn/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://www.sakuraus.cn/tags/mysql/"/>
    
      <category term="范式" scheme="https://www.sakuraus.cn/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开发流程</title>
    <link href="https://www.sakuraus.cn/2018/10/31/%E5%BF%AB%E8%B7%91%E8%80%85%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.sakuraus.cn/2018/10/31/快跑者基本开发流程/</id>
    <published>2018-10-31T13:13:30.015Z</published>
    <updated>2018-08-19T06:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的功能模块基本开发流程"><a href="#新的功能模块基本开发流程" class="headerlink" title="新的功能模块基本开发流程"></a>新的功能模块基本开发流程</h2><ol><li><p>首先，应该熟悉业务需求，了解功能逻辑，明确接口应该接受什么参数，进行什么处理以及返回什么结果</p></li><li><p>确定具体的业务逻辑，发现未知的逻辑漏洞，避免开发到一半的时候才发现逻辑上有问题</p></li><li><p>基于以下 demo 开发接口代码</p></li></ol><p><strong>Controller method demo:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public function api()</span><br><span class="line">&#123;</span><br><span class="line">// Stop one：判断接口调用权限</span><br><span class="line">$this-&gt;checkAuthorization($this-&gt;tokenInfo, [UserModel::LOGIN_ADMIN]);</span><br><span class="line"></span><br><span class="line">// Step two: 获取所有请求的参数</span><br><span class="line">$param1 = I(&apos;get.param1&apos;, &apos;&apos;);</span><br><span class="line">$param2 = I(&apos;get.param2&apos;, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">// Step three: 验证获取到的参数（取值是否正确）</span><br><span class="line">if ($param1 &lt;= 0) &#123;</span><br><span class="line">apiResponse(CodeModel::ERROR, &apos;param1 参数异常&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step four: 判断权限（比如判断商户和团队是否关联）</span><br><span class="line"></span><br><span class="line">// Step five: 进行具体的业务逻辑处理（一般会在相应的 Service 中创建一个同名方法进行处理）并返回结果（一般是 Resuful 风格的数据格式）</span><br><span class="line"></span><br><span class="line">// Step six: 解析返回结果（因为前端需要对返回数据进行一些处理，一般调用 *View::parse*()）</span><br><span class="line"></span><br><span class="line">// Step serven: 返回最终结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service method demo:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static function api()</span><br><span class="line">&#123;</span><br><span class="line">// 进行具体的业务逻辑处理</span><br><span class="line"></span><br><span class="line">// 注意：几乎所有数据都进行了缓存，因此如果数据库字段发生变更需要清除之前的缓存</span><br><span class="line"></span><br><span class="line">// 一般以 get 开头的方法表示获取数据，以 set/update/modify 等开头的表示更新数据</span><br><span class="line">// 在编写新的功能方法之前，要先看看是否已经存在相同功能的方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>代码编写完成之后，要先自己 review 一遍，检测代码逻辑、格式是否存在问题</p></li><li><p>检查完毕之后，自己<strong>测试</strong>一下接口是否实现目的（返回正确结果和返回错误结果）</p></li><li><p><code>Ctrl + Alt + L</code>，格式化一下代码（html,js 代码不用格式化）</p></li><li><p>提交代码，编辑合适的注释，推送到远端，找其他人 review code.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新的功能模块基本开发流程&quot;&gt;&lt;a href=&quot;#新的功能模块基本开发流程&quot; class=&quot;headerlink&quot; title=&quot;新的功能模块基本开发流程&quot;&gt;&lt;/a&gt;新的功能模块基本开发流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，应该熟悉业务需求，了解功能逻辑，明确
      
    
    </summary>
    
      <category term="php" scheme="https://www.sakuraus.cn/categories/php/"/>
    
    
      <category term="code" scheme="https://www.sakuraus.cn/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>日志记录</title>
    <link href="https://www.sakuraus.cn/2018/10/31/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%8C%87%E5%8D%97/"/>
    <id>https://www.sakuraus.cn/2018/10/31/代码日志记录指南/</id>
    <published>2018-10-31T13:13:29.767Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志记录的作用"><a href="#日志记录的作用" class="headerlink" title="日志记录的作用"></a>日志记录的作用</h2><p>记录事务发生的过程,方便排查问题</p><h2 id="日志记录的包含要素"><a href="#日志记录的包含要素" class="headerlink" title="日志记录的包含要素"></a>日志记录的包含要素</h2><blockquote><ul><li>request_id  事务发生唯一标识</li><li>time        时间</li><li>host        发生所在机器</li><li>code_line   事件发生所在代码行数 (分解为 file ,class , line )</li><li>message     事件描述</li></ul></blockquote><h2 id="日志记录等级"><a href="#日志记录等级" class="headerlink" title="日志记录等级"></a>日志记录等级</h2><blockquote><ul><li>ERROR   不符合代码预期，出现意外情况,比如: 数据库语句执行失败 </li><li>WARN    用户输入的数据不符合格式 用户某些操作失败, 比如: 用户登录失败</li><li>INFO    关键节点的流程描述 条件分支进入某流程</li><li>DEBUG   某个时刻,某个变量的值 SQL语句</li></ul></blockquote><h2 id="日志记录地点"><a href="#日志记录地点" class="headerlink" title="日志记录地点"></a>日志记录地点</h2><p>程序由三种结构组成:顺序,判断,循环</p><p>我们记录的日志要点: 清晰表现我们执行路径和我们这条路径上关注的某些值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;日志记录的作用&quot;&gt;&lt;a href=&quot;#日志记录的作用&quot; class=&quot;headerlink&quot; title=&quot;日志记录的作用&quot;&gt;&lt;/a&gt;日志记录的作用&lt;/h2&gt;&lt;p&gt;记录事务发生的过程,方便排查问题&lt;/p&gt;
&lt;h2 id=&quot;日志记录的包含要素&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Log" scheme="https://www.sakuraus.cn/categories/Log/"/>
    
    
      <category term="日志监控" scheme="https://www.sakuraus.cn/tags/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>第一次写博客 有点紧张 请大家多多关照</title>
    <link href="https://www.sakuraus.cn/2018/10/31/work/"/>
    <id>https://www.sakuraus.cn/2018/10/31/work/</id>
    <published>2018-10-31T13:13:29.555Z</published>
    <updated>2018-08-06T14:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to sakuraus.cn (～￣▽￣)～</p><p>Phper,目前在学习Golang,Db,和Docker方面的知识欢迎大家一起讨论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to sakuraus.cn (～￣▽￣)～&lt;/p&gt;
&lt;p&gt;Phper,目前在学习Golang,Db,和Docker方面的知识欢迎大家一起讨论&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis开发规范</title>
    <link href="https://www.sakuraus.cn/2018/10/31/Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://www.sakuraus.cn/2018/10/31/Redis开发规范/</id>
    <published>2018-10-31T13:13:28.884Z</published>
    <updated>2018-08-19T06:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>##Redis开发规范</p><h3 id="key名设计"><a href="#key名设计" class="headerlink" title="key名设计"></a>key名设计</h3><p>1.可读性和可管理性</p><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ugc:video:1</span><br></pre></td></tr></table></figure></p><p>2.简洁性</p><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125;简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125;。</span><br></pre></td></tr></table></figure><p>3.不要包含特殊字符</p><p>反例：包含空格、换行、单双引号以及其他转义字符</p><h3 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h3><p>1.拒绝bigkey(防止网卡流量、慢查询)</p><p>string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p><p>2.选择适合的数据类型。</p><p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setuser:1:nametom</span><br><span class="line"></span><br><span class="line">setuser:1:age19</span><br><span class="line"></span><br><span class="line">setuser:1:favor football</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmsetuser:1nametomage19favorfootball</span><br></pre></td></tr></table></figure><p>3.控制key的生命周期，redis不是垃圾桶。</p><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>1.O(N)命令关注N的数量</p><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><p>2.禁用命令</p><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><p>3.合理使用select</p><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><p>4.使用批量操作提高效率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原生命令：例如mget、mset。</span><br><span class="line"></span><br><span class="line">非原生命令：可以使用pipeline提高效率。</span><br><span class="line"></span><br><span class="line">但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</span><br></pre></td></tr></table></figure></p><p>注意两者不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原生是原子操作，pipeline是非原子操作。</span><br><span class="line"></span><br><span class="line">2. pipeline可以打包不同的命令，原生做不到</span><br><span class="line"></span><br><span class="line">3. pipeline需要客户端和服务端同时支持。</span><br></pre></td></tr></table></figure></p><p>5.Redis事务功能较弱，不建议过多使用</p><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p><p>6.Redis集群版本在使用Lua上有特殊要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，&quot;-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn&quot;</span><br><span class="line"></span><br><span class="line">b. 所有key，必须在1个slot上，否则直接返回error, &quot;-ERR eval/evalsha command keys must in same slotrn&quot;</span><br></pre></td></tr></table></figure><p>7.必要情况下使用monitor命令时，要注意不要长时间使用。</p><h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><p>1.单应用独立redis</p><p>避免多个应用使用一个Redis实例</p><p>正例：不相干的业务拆分，公共数据做服务化。</p><p>2.使用长连接或者连接池</p><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p><p>3.【建议】</p><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><p>4.【推荐】</p><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><p>5.【建议】</p><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p>其他策略如下：</p><p>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p><p>allkeys-random：随机删除所有键，直到腾出足够空间为止。</p><p>volatile-random:随机删除过期键，直到腾出足够空间为止。</p><p>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p><h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p>1.数据同步</p><p>redis间数据同步可以使用：redis-port</p><p>2.big key搜索</p><p><a href="https://yq.aliyun.com/articles/117042" target="_blank" rel="noopener">redis大key搜索工具</a></p><p>3.热点key寻找(内部实现使用monitor，所以建议短时间使用)</p><p><a href="https://github.com/facebookarchive/redis-faina" target="_blank" rel="noopener">facebook的redis-faina</a></p><p>阿里云Redis已经在内核层面解决热点key问题，欢迎使用。</p><h3 id="删除bigkey"><a href="#删除bigkey" class="headerlink" title="删除bigkey"></a>删除bigkey</h3><p>1.下面操作可以使用pipeline加速。<br>2.redis 4.0已经支持key的异步删除，欢迎使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. Hash删除: hscan + hdel</span><br><span class="line"></span><br><span class="line">b. List删除: ltrim</span><br><span class="line"></span><br><span class="line">c. Set删除: sscan + srem</span><br><span class="line"></span><br><span class="line">d. SortedSet删除: zscan + zrem</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Redis开发规范&lt;/p&gt;
&lt;h3 id=&quot;key名设计&quot;&gt;&lt;a href=&quot;#key名设计&quot; class=&quot;headerlink&quot; title=&quot;key名设计&quot;&gt;&lt;/a&gt;key名设计&lt;/h3&gt;&lt;p&gt;1.可读性和可管理性&lt;/p&gt;
&lt;p&gt;以业务名(或数据库名)为前缀(防止
      
    
    </summary>
    
      <category term="Redis" scheme="https://www.sakuraus.cn/categories/Redis/"/>
    
    
      <category term="redis" scheme="https://www.sakuraus.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>说明</title>
    <link href="https://www.sakuraus.cn/2018/10/31/README/"/>
    <id>https://www.sakuraus.cn/2018/10/31/README/</id>
    <published>2018-10-31T13:13:28.670Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本项目旨在收集常用规范以及常用最佳实践,方便引导新人和总结,欢迎大家积极提交新文档</p><h2 id="代码的合理性"><a href="#代码的合理性" class="headerlink" title="代码的合理性"></a>代码的合理性</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ol><li><a href="前端规范.md">前端规范</a></li><li><a href="git的基本使用.md">Git使用指南</a></li><li><a href="php开发注意事项.md">PHP开发注意事项</a></li><li><a href="Redis开发规范.md">Redis开发规范</a></li><li><a href="数据库规范.md">数据库设计基本规范</a></li><li><a href="http://gitlab.lingdianit.com/lingdianit/php-demo" target="_blank" rel="noopener">WEB项目常用组成</a></li><li><a href="应用发版规范.md">应用发版规范</a></li></ol><h2 id="讨论和复阅"><a href="#讨论和复阅" class="headerlink" title="讨论和复阅"></a>讨论和复阅</h2><ol><li><a href="gitlab使用简介.md">GITLAB指南</a></li><li><a href="代码复阅方式.md">复阅方式</a></li></ol><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ol><li>功能的设计和开发说明</li><li>日常的最佳实践</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>单元测试</li><li>功能测试</li><li>环境统一性,部署环境的可迁移性和统一性(本地,测试,预发布,生产),详见<a href="http://gitlab.lingdianit.com/lingdianit/php-demo" target="_blank" rel="noopener">php-demo</a></li><li>数据库版本的统一性</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>规范</li><li>具体部署方法</li></ol><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h4 id="值班规范"><a href="#值班规范" class="headerlink" title="值班规范"></a>值班规范</h4><ol><li>值班规范</li></ol><h4 id="服务的监控"><a href="#服务的监控" class="headerlink" title="服务的监控"></a>服务的监控</h4><ol><li>外部服务的自动监控和报警</li><li>内部日志的自动监控和报警</li></ol><h3 id="故障快速定位和恢复"><a href="#故障快速定位和恢复" class="headerlink" title="故障快速定位和恢复"></a>故障快速定位和恢复</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><ol><li>日志的集中性</li><li>日志的快速定位和复现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本项目旨在收集常用规范以及常用最佳实践,方便引导新人和总结,欢迎大家积极提交新文档&lt;/p&gt;
&lt;h2 id=&quot;代码的合理性&quot;&gt;&lt;a href=&quot;#代码的合理性&quot; class=&quot;headerlink&quot; title=&quot;代码的合理性&quot;&gt;&lt;/a&gt;代码的合理性&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发注意事项</title>
    <link href="https://www.sakuraus.cn/2018/10/31/php%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://www.sakuraus.cn/2018/10/31/php开发注意事项/</id>
    <published>2018-10-31T13:13:28.180Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本代码规范"><a href="#基本代码规范" class="headerlink" title="基本代码规范"></a>基本代码规范</h1><p><a href="php后端代码规范.md">PHP代码规范</a></p><h2 id="接口开发"><a href="#接口开发" class="headerlink" title="接口开发"></a>接口开发</h2><p><a href="应用程序API约定.md">应用程序api约定</a></p><h2 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h2><p><a href="http://document.thinkphp.cn/manual_3_2.html#input_filter" target="_blank" rel="noopener">TP安全策略</a><br><a href="http://wiki.jikexueyuan.com/project/go-web-programming/09.0.html" target="_blank" rel="noopener">WEB安全</a></p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>常规MVC ,我们把M,进一步拆分 M = dbModel + Service + Cache</p><p>具体表现:  数据模型层 + 业务服务成 + 缓存</p><p>数据模型层: 只保留db相关字段常量定义和字段验证</p><p>业务服务层: 不应该出现任何Session,Cookie 类信息,只专注业务交互,不一定与DB一一对应</p><h2 id="异常使用和错误记录问题"><a href="#异常使用和错误记录问题" class="headerlink" title="异常使用和错误记录问题"></a>异常使用和错误记录问题</h2><p>不建议使用异常,因为有时忘记捕获异常,直接导致程序异常终止</p><p>日志记录使用参考(代码日志记录指南)[代码日志记录指南.md]</p><h2 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h2><p>合理使用 内存缓存和静态页面缓存</p><p>redis-hash 使用一定要注意key 的数量,数量不要大于1千, 另外一定要及时清理</p><p>缓存一定要保证能重建</p><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>数据量都至少按百万数量级,所以开发过程中一定要主要索引的使用</p><h2 id="第三方接口的熔断"><a href="#第三方接口的熔断" class="headerlink" title="第三方接口的熔断"></a>第三方接口的熔断</h2><p>自动熔断实现</p><p>配置实现</p><h2 id="代码的测试"><a href="#代码的测试" class="headerlink" title="代码的测试"></a>代码的测试</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本代码规范&quot;&gt;&lt;a href=&quot;#基本代码规范&quot; class=&quot;headerlink&quot; title=&quot;基本代码规范&quot;&gt;&lt;/a&gt;基本代码规范&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;php后端代码规范.md&quot;&gt;PHP代码规范&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;接口开发&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="分层设计" scheme="https://www.sakuraus.cn/categories/%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="php" scheme="https://www.sakuraus.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP基本代码规范</title>
    <link href="https://www.sakuraus.cn/2018/10/31/php%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://www.sakuraus.cn/2018/10/31/php后端代码规范/</id>
    <published>2018-10-31T13:13:27.961Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本代码规范"><a href="#基本代码规范" class="headerlink" title="基本代码规范"></a>基本代码规范</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote><ul><li>PHP 代码中 <code>必须</code> 使用 <code>&lt;?php ?&gt;</code> 或者 <code>&lt;?= ?&gt;</code>，而不可使用其他标签</li><li>所有的 PHP 文件 <code>必须</code> 使用 <code>Unix LF</code> (换行)作为行结束符</li><li>只有 PHP 代码的文件关闭标签 <code>?&gt;</code> <code>必须</code> 省略</li><li>PHP 代码 <code>必须</code> 使用 <code>UTF-8 without BOM</code> 编码</li><li>建议每行代码字符数保持在80个以内，理论上不可多于120个，但不做硬性限制</li></ul></blockquote><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><blockquote><ul><li>命名空间 <code>Namespace</code> 和类 <code>class</code> <code>必须</code> 遵循”autoloading” PSR标准: [PSR0,PSR-4].</li><li>类名（<code>class</code>）<code>必须</code> 使用大驼峰命名法，如 <code>StudlyCaps</code></li><li>类中的常量 <code>必须</code> 只能用 <code>大写字母</code> 和 <code>_</code> 来命名</li><li>类中的属性 <code>必须</code> 使用驼峰命名法，如 <code>$camelCase</code></li><li>方法名（<code>method</code>）<code>必须</code> 使用驼峰命名法，如 <code>camelCase</code></li><li>PHP 的关键词 <code>keywords</code> <code>必须</code> 用小写,PHP 中的常量 <code>true</code>，<code>false</code>，<code>null</code> <code>必须</code> 全部小写</li></ul></blockquote><h2 id="缩进-换行"><a href="#缩进-换行" class="headerlink" title="缩进,换行"></a>缩进,换行</h2><blockquote><ul><li>代码 <code>必须</code> 使用 <code>4个空格</code> 的缩进，而不是制表符 <code>tab</code>,遇到 { 应该进行一次缩进</li><li>在 <code>namespace</code> 声明下面 <code>必须</code> 有一个空行，并且 <code>use</code> 声明代码块下面也必须有一个空行</li><li>类开始的花括号 <code>必须</code> 放到下一行，结束花括号 <code>必须</code> 放在主体的下一行</li><li>方法和控制结构（译者注：<code>for</code>，<code>while</code> 等）开始花括号 <code>必须</code> 放在同一行，结束花括号 <code>必须</code> 放在控制主体的下一行</li><li>空行 可以 用来改善可读性和区分相关的代码块,方法与方法之间必须有空行,适当的地方可以添加空行</li></ul></blockquote><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><blockquote><ul><li>当进行函数或方法调用的时候，在方法或者函数名与左括号之间 <code>不可</code> 有空格，左括号之后 <code>不可</code> 有空格，右括号之前 <code>不可</code> 有空格,</li><li>参数列表中，逗号之前 <code>不可</code> 有空格，</li><li>$i++ 这种完整体不可有空格</li><li>语句结束 <code>;</code> 不可有空格</li><li>其他情况: <code>=</code> , 关键词 与 大括号之间,都应该有空格</li></ul></blockquote><h2 id="代码过长的换行问题"><a href="#代码过长的换行问题" class="headerlink" title="代码过长的换行问题"></a>代码过长的换行问题</h2><blockquote><ul><li>当代码超过80行,建议换行,如参数列表,保留句尾的逗号,下一个参数直接换行,与第一列参数缩4个空格</li><li>多条件 &amp;&amp; 作为下一行开始</li></ul></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><ul><li>所有的属性 必须 显式声明可见性,一个语句 不可 声明多个属性</li><li>所有的方法 必须 显式声明可见性,<code>abstract</code> 和 <code>final</code> 声明必须在显式声明可见性之前，<code>static</code> 声明必须在显式声明可见性之后,final public static function</li><li>所有变量的声明必须显示初始化</li></ul></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch ($expr) &#123;</span><br><span class="line">    case 0:</span><br><span class="line">        echo &apos;First case, with a break&apos;;</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        echo &apos;Second case, which falls through&apos;;</span><br><span class="line">        // no break</span><br><span class="line">    case 2:</span><br><span class="line">    case 3:</span><br><span class="line">    case 4:</span><br><span class="line">        echo &apos;Third case, return instead of break&apos;;</span><br><span class="line">        return;</span><br><span class="line">    default:</span><br><span class="line">        echo &apos;Default case&apos;;</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本代码规范&quot;&gt;&lt;a href=&quot;#基本代码规范&quot; class=&quot;headerlink&quot; title=&quot;基本代码规范&quot;&gt;&lt;/a&gt;基本代码规范&lt;/h1&gt;&lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="PHP" scheme="https://www.sakuraus.cn/categories/PHP/"/>
    
    
      <category term="php" scheme="https://www.sakuraus.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.sakuraus.cn/2018/10/31/phpstrom_key/"/>
    <id>https://www.sakuraus.cn/2018/10/31/phpstrom_key/</id>
    <published>2018-10-31T13:13:27.615Z</published>
    <updated>2018-10-13T13:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ctrl+D 复制一行<br>docker run -itd –name redis-master1 -v /test test_1  –net mynetwork -p 6379:6379 –ip 172.10.0.5  redis-m<br>docker exec -it 471 bash</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ctrl+D 复制一行&lt;br&gt;docker run -itd –name redis-master1 -v /test test_1  –net mynetwork -p 6379:6379 –ip 172.10.0.5  redis-m&lt;br&gt;docker exec -i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>keloop 迭代</title>
    <link href="https://www.sakuraus.cn/2018/10/31/keloop/"/>
    <id>https://www.sakuraus.cn/2018/10/31/keloop/</id>
    <published>2018-10-31T13:13:27.091Z</published>
    <updated>2018-08-06T12:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://o2o.keloop.cn/" target="_blank" rel="noopener">keloop</a> 第三次迭代</p><h3 id="平台首页"><a href="#平台首页" class="headerlink" title="平台首页"></a>平台首页</h3><ul><li>1 <a href="https://pro.modao.cc/app/ad7875830e7833f2bdcd0f58c3d7356ab80d03f4#screen=sfae74949f962739b316e59" target="_blank" rel="noopener">平台首页</a></li></ul><blockquote><ul><li>1.1 基于之前的页面配置之上 添加一个管理分类兼容之前的页面配置</li><li>1.2 由于第一版页面配置和平台首页是一对一的关系 需要调整下表结构</li><li>1.3 现在迭代的版本需要实现一个平台能有多个平台首页(一对多的关系)</li><li>1.4 首先需要在 <strong>module</strong> 模块 数据表中 添加一个 <code>module_type_id</code> 加一个分类id</li><li>1.5 在 <strong>module_type</strong> 表中记得把 模块排序一起存上</li></ul></blockquote><h3 id="店铺设置"><a href="#店铺设置" class="headerlink" title="店铺设置"></a>店铺设置</h3><ul><li>2 <a href="https://pro.modao.cc/app/ad7875830e7833f2bdcd0f58c3d7356ab80d03f4#screen=s97A0FEAD9A1533448292648" target="_blank" rel="noopener">店铺设置</a></li></ul><blockquote><ul><li>2.1 需要添加的字段(店铺大图,店铺业务,支付方式分为平台支付,和店铺自己配置支付)</li><li>2.2 店铺相册需要 一个分类表 ,一个类型详情(把平台id和分类id做联合索引)</li><li>2.3 如果 店铺业务存放成一个二进制数组 查询列表比较麻烦看到时候是吧分开还是聚合</li><li>2.4 其他信息共用之前的数据 </li><li>2.5 tips:<a href="https://note.youdao.com/share/?id=5a15c447684d6bb6952d706c2e02e026&amp;type=note#/" target="_blank" rel="noopener">店铺类型</a>固定成常量 数据库存储一个店铺类型就可以了</li><li>2.6 店铺配置中的 外送业务 (外卖),开启团购服务必须购买了市场应用才行</li><li>2.7 是否预定之前的好像没有配置 如果没有在shop_info中添加一个添加一个是否预定的状态</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://o2o.keloop.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;keloop&lt;/a&gt; 第三次迭代&lt;/p&gt;
&lt;h3 id=&quot;平台首页&quot;&gt;&lt;a href=&quot;#平台首页&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git基本操作</title>
    <link href="https://www.sakuraus.cn/2018/10/31/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.sakuraus.cn/2018/10/31/git的基本使用/</id>
    <published>2018-10-31T13:13:26.591Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p><a href="http://www.oschina.net/translate/a-successful-git-branching-model" target="_blank" rel="noopener">GIT分支模型</a></p><h2 id="git基本操作步骤"><a href="#git基本操作步骤" class="headerlink" title="git基本操作步骤"></a>git基本操作步骤</h2><ol><li><p>添加用户名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure></li><li><p>添加常见配置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.fe  fetch -p</span><br><span class="line">git config --global alias.pu push</span><br></pre></td></tr></table></figure></li><li><p>常用命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git init .                                  //初始化  </span><br><span class="line">git br  dev                                 //创建本地dev分支  </span><br><span class="line">git add newfile                             //提交新文件到暂存区  </span><br><span class="line">git commit -m &apos;add new file&apos;                //提交到本地仓库  </span><br><span class="line">git remote add origin git@xx.com:demo.git   //添加远程仓库地址  </span><br><span class="line">git fetch origin  -p                        // 同步本地远程仓库镜像  </span><br><span class="line">git merge origin/dev                        // 合并远端dev分支  </span><br><span class="line">git push origin dev:dev                     //把本地dev 推送到远端  </span><br><span class="line">git br feature-new origin/dev               // 基于远端dev 创建新分支 feature-new  </span><br><span class="line">git add newfeature.txt                      //提交新文件到暂存区  </span><br><span class="line">git ci -m &apos; finish new feature&apos;             //提交到本地仓库  </span><br><span class="line">git co dev                                  // 切换回本地dev分支  </span><br><span class="line">git merge newfeature                        // 本地dev分钟 合并 newfeature分支  </span><br><span class="line">git br -d newfeature                        // 合并完成,删除 newfeature 分支  </span><br><span class="line">git push origin :newfeature                 // 删除远端 newfeature 分支</span><br><span class="line">git fetch origin -p                         // 同步远端代码到本地  </span><br><span class="line">git merge origin/dev                        // 合并</span><br><span class="line">git push origin dev:dev                     // 推送本地dev到远端dev</span><br></pre></td></tr></table></figure></li><li><p>冲突解决<br>当二个人同时更改了文件的某些部分,合并时将会出现冲突,此时,可找到另外一个人,仔细对比代码,手动删除不需要的代码,保留合理代码,然后提交<br>两个可能用到的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --ours  conflict.php     //使用自己分支的代码,抛弃合并过来冲突</span><br><span class="line">git checkout --theirs conflict.php     //使用合并分支的代码,抛弃自己冲突这块更改的代码</span><br></pre></td></tr></table></figure></li></ol><h2 id="git-分支使用模型"><a href="#git-分支使用模型" class="headerlink" title="git 分支使用模型"></a>git 分支使用模型</h2><ol><li><p>两大主分支</p><p>master   随时都是一个预备生产状态。  生产分支</p><p>dev      下个发布版的最新软件变更，每晚自动构建得来 集成分支</p></li><li><p>辅助性分支  </p></li></ol><ul><li><p>新功能，优化，修复</p><p>一般基于dev 分支创建<br>命名 feature-*</p><p>创建新功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-coupon origin/dev</span><br><span class="line">Switched to a new branch &quot;feature-coupon&quot;</span><br></pre></td></tr></table></figure></li></ul><p>  合并新功能到dev 分支</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br><span class="line">$ git merge --no-ff feature-coupon</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git branch -d feature-coupon</span><br><span class="line">Deleted branch feature-coupon (was 05e9557).</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>  注意  –no-ff   创建一个新的commit节点</p><ul><li><p>发布分支</p><p>  当dev分支达到理想的发布状态时，从dev分支来，最后一定要合并到dev和master，命名方式为：release-* release分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-1.2 dev</span><br><span class="line">Switched to a new branch &quot;release-1.2&quot;</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>  发布到master</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure><p>  合并到dev上</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure></li></ul><pre><code>完成删除 release<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>热修复分支<br>  从master来，用于修复线上紧急BUG，命名 hotfix-*</p><p>  创建新hotfix ，修改版本编号</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch &quot;hotfix-1.2.1&quot;</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure></li></ul><pre><code>完成hotfix之后，需要把合并到master和dev分支去，这样就可以保证修复的这个bug也包含到下一个发行版中。这一点和完成release分支很相似。合并完成后，删除hotfix分支</code></pre><p>  <img src="http://nvie.com/img/git-model@2x.png" alt="image"></p><h2 id="git-commit-规范"><a href="#git-commit-规范" class="headerlink" title="git commit 规范"></a>git commit 规范</h2><p>  git commit 回答三个问题<br>   修改是什么？</p><p>   用什么方法修改的?</p><p>   这些方法可能影响什么地方?</p><p>  每次commit只能包含一个改动</p><p>  每次commit必须单独写提交信息</p><p>  格式如下</p><blockquote><p> 修复client端不能登陆的BUG<br> 以前的方法判断用户唯一错误，少判断用户状态<br> 影响client端用户登陆  </p></blockquote><h2 id="git小测试"><a href="#git小测试" class="headerlink" title="git小测试"></a>git小测试</h2><ol><li>gitlab.lingdianit.com 使用公司提供qq号注册</li><li>项目测试<ul><li>新建一个项目 ldtest</li><li>新建 README.md 文件,里面写清楚 此项目的简介</li><li>新建目录doc</li><li>创建远程dev,master分支</li><li>基于dev,新建新分支  feature-db ,在新分支里面添加 db.txt ,内容任意,推送到远端 feature-db</li><li>基于dev,新建新分支  feature-rush, 在新分支里面添加 rush.html, 提交,dev分支合并 featue-rush ,删除 feature-rush,推送dev到远端dev</li><li>基于master,新建新分支  hotfix-rush, 在新分支里面添加 rush-fix.html ,master,dev 都合并 hotfix-rush,删除hotfix-rush,dev,master推送对应远端dev,master</li></ul></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.oschina.net/translate/a-successful-git-branching-model" target="_blank" rel="noopener">GIT分支模型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读&quot;&gt;&lt;a href=&quot;#阅读&quot; class=&quot;headerlink&quot; title=&quot;阅读&quot;&gt;&lt;/a&gt;阅读&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.oschina.net/translate/a-successful-git-branching-m
      
    
    </summary>
    
      <category term="Git" scheme="https://www.sakuraus.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.sakuraus.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>gitlab使用简介</title>
    <link href="https://www.sakuraus.cn/2018/10/31/gitlab%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.sakuraus.cn/2018/10/31/gitlab使用简介/</id>
    <published>2018-10-31T13:13:26.330Z</published>
    <updated>2018-08-19T06:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitlab使用简介"><a href="#gitlab使用简介" class="headerlink" title="gitlab使用简介"></a>gitlab使用简介</h1><p>gitlab地址  <a href="https://gitlab.lingdianit.com" target="_blank" rel="noopener">https://gitlab.lingdianit.com</a> </p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>使用公司QQ号注册</li><li>添加自己电脑公钥</li><li>按<a href="git的基本使用">git的基本使用</a>里面使用</li></ol><h2 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h2><ol><li>领取任务后,新建自己的功能分支</li><li>多次提交,完善功能后,把功能分支推送到远端</li><li>创建一个请求 合并到dev的申请,请参考<a href="git的基本使用.md">git基本使用</a> 分支使用流程</li><li>经过二人复阅,合并到dev</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gitlab使用简介&quot;&gt;&lt;a href=&quot;#gitlab使用简介&quot; class=&quot;headerlink&quot; title=&quot;gitlab使用简介&quot;&gt;&lt;/a&gt;gitlab使用简介&lt;/h1&gt;&lt;p&gt;gitlab地址  &lt;a href=&quot;https://gitlab.ling
      
    
    </summary>
    
      <category term="gitlab" scheme="https://www.sakuraus.cn/categories/gitlab/"/>
    
    
      <category term="gitlab" scheme="https://www.sakuraus.cn/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.sakuraus.cn/2018/10/31/hello-world/"/>
    <id>https://www.sakuraus.cn/2018/10/31/hello-world/</id>
    <published>2018-10-31T10:14:02.665Z</published>
    <updated>2018-10-31T10:14:02.665Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
